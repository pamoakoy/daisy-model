Daisy kildekode.
================

Udviklingen af Daisy begyndte i slutningen af 80'erne som en del af
NPO-programmet, og har været i gang med varierende intensitet siden da
under mange forskellige projekter.  En enkelt omskrivning blev det til
i midten af 90'erne.  I dag er kildekoden til Daisy på lige knap
100.000 linier, hvilket er ti gange mere end den første færdige
version fra 1990.  Daisy kan simulere ca. 100 forskellige processer,
med dobbelt så mange modeller.

Alt dette repræsenterer en kompleksitet det er en udfordring at holde
styr på.  En tommelfingerregel er at man med brug af struktureret
programmering kan holde styr på et program på ca. 10.000 linier kode,
hvis man er godt inde i det.  Hvilket også var den oprindelige
størrelse af Daisy.  Dernæst voksede programmet som der var behov for
udvidelser i forbindelse med diverse projekter, indtil det blev
uoverkommeligt at tilføje de nye fasciliteter der var behov for, uden
at at risikere at ødelægge nogle af de eksisterende fasciliteter.
Dette er ikke en atypisk udvikling for videnskabelige applikationer,
og man ser da også at nogle applikationer deler sig fra samme kerne
til projektspecifikke versioner.  Det er en måde at reducere
kompleksiteten, men gør det vanskeligt for de forskellige projekter at
drage nytte af hinandens erfaringer.  I midten af 90'erne valgte
forskningsnetværket Dina at financiere om omskrivning af Daisy,
baseret på datalogiske principper.

Indenfor faget datalogi er der udviklet en række værktøjer til
håndtering af kompleksitet.  Det vigtigste af disse er "del-og-hersk"
princippet.  Hvis det er muligt, kan man prøve at opdele et stort og
uoverskueligt problem i en række mindre og overskuelige problemer.
For at fungere kræver det at man kan fokusere på et enkelt delproblem,
uden at skulle inddrage viden om de øvrige delproblemer.  Princippet
kommer til udtryk mange steder indenfor datalogien, for eksempel i
modulbegrebet.  Et modul vil indholde data, i en simuleringsmodel
typisk oplysninger om systemets tilstand, og funktioner, i en
simuleringsmodel typisk en beskrivelse af de processer der fører
systemet fra en tilstand til en anden.  

Et enkelt modul vil typisk være beskrevet ved et interface, som er den
del de andre moduler vil kunne se, og en implementation som er den del
af modulet der er skjult for de øvrige moduler.  Et godt programdesign
efter "del-og-hersk" principet er således en opdeling af programmet i
moduler, hvor interfacet til hvert modul er så minimalt som muligt.
Jo mindre interfacet er, jo mindre skal man tage hensyn til de øvrige
delproblemer, når man implementerer det delproblem som det aktuelle
modul repræsenterer. "Del-og-hersk" er ikke det eneste princip man
skal tage hensyn til når man designer et program.  For eksempel skal
hvert modul i en simuleringsmodel også helst repræsentere et begreb
der er genkendeligt fra den verden der simuleres for at undgå at der
bliver for stor forskel på "sproget" i programmeringsverdenen og i den
verden der bliver modeleret, med tilhørende oversættelsesproblemer.
Men del-og-hersk princippet er det der har direkte at gøre med
håndteringen af komplekstet at gøre.

Ovenstående beskrivelse af moduler indeholder to opdelinger, der hver
leder til to tricks indenfor datalogien.  Den første opdeling er
mellem data og funktion.  Modulets data varierer gennem
programkørslen, medens at funktionerne er de samme.  Det betyder at
man kan have flere sæt af data fra samme modul "aktive" på samme tid.
Dette trick kaldes objekt-baseret baseret programmering.  I Daisy er
det netop dette trick der gør at man kan regne på to søjler på samme
tid, det er simpelthen to instansieringer af samme modul, hvor hver
instans har sin egen tilstand.

Den formelle skelnen mellem interface og implementation i moduler
leder yderligere hen til et af de mest populære trick i datalogiens
verden, nemlig at have flere implementationer af det samme interface.
Dette trick kaldes (når det kombineres med objekt-baseret
programmering) for objekt-orienteret programmering, og er i dag langt
den mest populære måde at strukturere sine programmer på.  Med OOP
skifter terminologien også, moduler bliver til klasser, men
repræsenterer stadig data og funktioner.  Når en klasse bliver
instantieret (man laver nyt kopi af klassens data) kaldes instansen et
objekt, deraf navnet OOP.

Ved omskrivningen i midten af 90'erne blev Daisy da også designet
omkring objekt-orienteret programmering.  Når Daisy som nævnt i
indledningen i dag har dobbelt så mange modeller som processer, så
skyldes det at hver process repræsenteres af et interface, og hver
model af en implementation af et sådant interface.  OOP tillader
således at vi har flere implementationer (modeller) af hvert interface
(process).  Et ekesmpel er transport af vand, hvor man kan vælge
mellem en simpelt model hvor hvert lag i jorden har en fast kapacitet,
samt en mere kompleks men fysisk mere korrekt beskrivelse ved Richards
ligning.  Transport af vand regnes her for en process, og
"fast-kapacitet" og Richards ligning for to forskellige modeller for
denne process.  I den nye udgave af Daisy kan brugeren så vælge
hvilken model han ønskede for hver process ved at angive navnet på
modellen i en opsætningsfil, samt hvilke parametre han ønsker at
anvende den model med.  For at gøre Daisy anvendelig for folk der ikke
lige har alle 100 processer og 200 modeller i hovedet, samt
overblikket til at vælge mellem dem, har vi valgt at lade Daisy bruge
de modeller vi generelt har mest tillid til når brugeren ikke angiver
andet.

Dette design har hvor brugeren vælger delmodel har gjort det muligt
for Daisy at vokse i forbindelse med diverse projekter, uden at bryde
sammen i kompleksistet eller blive opdelt i flere varianter.  De
enkelte projekter har ofte enten brug for en ny model til en
eksisterende process, eller for at tilføje en ny process hvor vi så
som oftest sørger for at bruge en "dummy" model der anvendes hvor
intet andet angives, så de øvrige processer ikke påvirkes.

Dette design er ikke uden en pris, generelt bruges halvdelen af koden
i Daisy på at vedligeholde den fleksibiltet som er beskrevet ovenfor,
og en given projekt-specifik funktionalitet ville kunne implementeres
dobbelt så hurtigt hvis man droppede kravet om at det skulle kunne
indgå i den fælles Daisy kode på lige fod med funktionalitet
implementeret i forbindelse med andre projekter.  Synergien mellem
funktionaliteten i de forskellige projekter gør dog at denne pris i
høj grad er værd at betale.

Når man bruger OOP bliver et nyt princip relevant for designet af
programmet, nemlig at hvert modul vælges så det svarer til de
funktioner man kunne ønske at udskifte.  Eftersom man ofte ikke ved
det på forhånd, betyder det at en kontinuerligt redesign af programmet
er ønskværdigt efterhånden som det udvikler sig.

R2D2 redesign
=============

Udvidelsen af Daisy til at regne i to dimensioner piller ved det
grundlæggende design på to punkter.  

For det første er geomtrien ikke længere blot en lodret opdeling af
jorden i numeriske lag.  I Daisy var geomtrien representeret ved et
modul, det vil altså sige et interface med en enkelt implementation.
Første punkt ved R2D2 redesignet var at konvertere dette til en klasse
med et interface der var generelt nok til at klare en opdeling af
jorden i arbitrære 2D eller 3D polygoner, hvilket skulle fremtidssikre
denne.  I første omgang blev der så implementeret den klassiske 1D
geometri, og en 2D rektangulær geometri.  På sigt er det så meningen
at udvide dette med en trapez-geometri til f.eks. at modellere kamme.  

Det andet punkt var transportprocesserne, der traditionelt var knyttet
til de enkelte stoffer som skulle transporteres, og
omsætningsprocesserne.  I forbindelse med R2D2 projektet var denne
opdeling uhensigtmæssig, i stedet var det en fordel at knytte
transportprocesserne tæt til valget af geometri 8de modeller man
bruger til transport er generelt stærkt geometriafhængige), og
samtidig justere omsætningsprocesserne så disse var uafhængige af
valget af geometri.

Dette betyder et omfattende restruktureringsarbejde da næsten alle
moduler er påvirket, men også at brugere af 1D Daisy kun vil blive
minimalt påvirket, da al 2D arbejdet kommer til at foregå i et seperat
modul.  Kun hvis de brugerne har været inde og eksplicit vælge
transportmodel, hvilket hører til sjældenhederne, vil de bliver
påvirket.  

Samtidig betyder det at hele omsætningsdelen fortsat vil være fælles
mellem 1D og 2D Daisy, og at alle forbedringer af denne derfor vil
komme brugere af begge til gode.  Det samme gælder generelle
forbedringer i programmets "infrastruktur", såsom læsning af
opsætningsfiler, generering og processering af resultatfiler, samt
dokumentation.
