// condition_crop.C
// 
// Copyright 1996-2001, 2003 Per Abrahamsen and Søren Hansen
// Copyright 2000-2001, 2003 KVL.
//
// This file is part of Daisy.
// 
// Daisy is free software; you can redistribute it and/or modify
// it under the terms of the GNU Lesser Public License as published by
// the Free Software Foundation; either version 2.1 of the License, or
// (at your option) any later version.
// 
// Daisy is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser Public License for more details.
// 
// You should have received a copy of the GNU Lesser Public License
// along with Daisy; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// Checking crop state.

#define BUILD_DLL

#include "condition.h"
#include "block.h"
#include "crop.h"
#include "field.h"
#include "daisy.h"
#include "check_range.h"
#include "mathlib.h"
#include "librarian.h"

// The 'crop_ds_after' condition.

struct ConditionDSAfter : public Condition
{
  const symbol crop;
  const double ds;

  bool match (const Daisy& daisy, const Scope&, Treelog&) const
  { 
    const double crop_ds = daisy.field->crop_ds (crop); 
    if (!approximate (crop_ds, Crop::DSremove) && crop_ds >= ds)
      return true;
    return false;
  }
  void output (Log&) const
  { }

  void tick (const Daisy&, const Scope&, Treelog&)
  { }

  void initialize (const Daisy&, const Scope&, Treelog&)
  { }

  bool check (const Daisy&, const Scope&, Treelog&) const
  { return true; }

  ConditionDSAfter (Block& al)
    : Condition (al),
      crop (al.name ("crop")),
      ds (al.number ("ds"))
  { }
};

static struct ConditionCropDSSyntax
{
  static Model& make (Block& al)
  { return *new ConditionDSAfter (al); }

  ConditionCropDSSyntax ()
  {
    Syntax& syntax = *new Syntax ();
    AttributeList& alist = *new AttributeList ();
    alist.add ("description", "\
True iff the crop has reached development stage 'ds'.");
    syntax.add ("crop", Syntax::String, Syntax::Const,
                "Name of crop on the field to test.\n\
Specify \"all\" to use combined weight of all crops on the field in test.");
    static RangeII ds_range (-1.0, 2.0);
    syntax.add ("ds", Syntax::None (), ds_range, Syntax::Const,
                "Development stage [-1.0:2.0].");
    syntax.order ("crop", "ds");
    Librarian::add_type (Condition::component, "crop_ds_after",
                                      alist, syntax, &make);
  }
} ConditionCropDS_syntax;

// The 'crop_dm_over' condition.

struct ConditionDMOver : public Condition
{
  const symbol crop;
  const double weight;
  const double height;

  bool match (const Daisy& daisy, const Scope&, Treelog&) const
  { return (daisy.field->crop_dm (crop, height) >= weight); }

  void output (Log&) const
  { }

  void tick (const Daisy&, const Scope&, Treelog&)
  { }

  void initialize (const Daisy&, const Scope&, Treelog&)
  { }

  bool check (const Daisy&, const Scope&, Treelog&) const
  { return true; }

  ConditionDMOver (Block& al)
    : Condition (al),
      crop (al.name ("crop")),
      weight (al.number ("weight")),
      height (al.number ("height"))
  { }
};

static struct ConditionCropDMSyntax
{
  static Model& make (Block& al)
  { return *new ConditionDMOver (al); }

  ConditionCropDMSyntax ()
  {
    Syntax& syntax = *new Syntax ();
    AttributeList& alist = *new AttributeList ();
    alist.add ("description", "\
True iff the crop has reached the specified amount of dry matter.");
    syntax.add ("crop", Syntax::String, Syntax::Const,
                "Name of crop on the field to test.");
    syntax.add ("weight", "kg DM/ha", Check::non_negative (), Syntax::Const,
                "\
Amount of non-root dry-matter required for the condition to be true.");
    syntax.add ("height", "cm", Check::non_negative (), Syntax::Const,
                "\
Height above which we measure the DM weight.");
    alist.add ("height", 0.0);
    syntax.order ("crop", "weight");
    Librarian::add_type (Condition::component, "crop_dm_over",
                         alist, syntax, &make);
  }
} ConditionCropDM_syntax;

// The 'crop_dm_sorg_over' condition.

struct ConditionDMSOrgOver : public Condition
{
  const symbol crop;
  const double weight;

  bool match (const Daisy& daisy, const Scope&, Treelog&) const
  { return (daisy.field->crop_sorg_dm (crop) >= weight); }

  void output (Log&) const
  { }

  void tick (const Daisy&, const Scope&, Treelog&)
  { }

  void initialize (const Daisy&, const Scope&, Treelog&)
  { }

  bool check (const Daisy&, const Scope&, Treelog&) const
  { return true; }

  ConditionDMSOrgOver (Block& al)
    : Condition (al),
      crop (al.name ("crop")),
      weight (al.number ("weight"))
  { }
};

static struct ConditionCropDMSorgSyntax
{
  static Model& make (Block& al)
  { return *new ConditionDMSOrgOver (al); }

  ConditionCropDMSorgSyntax ()
  {
    Syntax& syntax = *new Syntax ();
    AttributeList& alist = *new AttributeList ();
    alist.add ("description", "\
True iff the storage organ has reached the specified amount of dry matter.");
    syntax.add ("crop", Syntax::String, Syntax::Const,
                "Name of crop on the field to test.");
    syntax.add ("weight", "kg DM/ha", Check::non_negative (), Syntax::Const,
                "\
Amount of non-root dry-matter required for the condition to be true.");
    syntax.order ("crop", "weight");
    Librarian::add_type (Condition::component, "crop_dm_sorg_over",
                         alist, syntax, &make);
  }
} ConditionCropDMSorg_syntax;

// condition_crop.C ends here.
