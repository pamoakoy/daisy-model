// format_LaTeX.C --- LaTeX text formatting.
// 
// Copyright 2005 Per Abrahamsen and KVL.
//
// This file is part of Daisy.
// 
// Daisy is free software; you can redistribute it and/or modify
// it under the terms of the GNU Lesser Public License as published by
// the Free Software Foundation; either version 2.1 of the License, or
// (at your option) any later version.
// 
// Daisy is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser Public License for more details.
// 
// You should have received a copy of the GNU Lesser Public License
// along with Daisy; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA


#include "format.h"
#include "version.h"
#include <ostream>
#include <map>

struct FormatLaTeX : public Format
{
  // Nesting.
  void item_open (const std::string& name);
  void item_close ();
  void section_open (const std::string& type, const std::string& title,
		     const std::string& scope, 
		     const std::string& label);
  void section_close ();
  void document_open ();
  void document_close ();

  // Use.
  void text (const std::string& name);
  void bold (const std::string& name);
  void italic (const std::string& name);
  void verbatim (const std::string& name);
  void special (const std::string& name);
  void soft_linebreak ();
  void hard_linebreak ();
  void new_paragraph ();
  void index (const std::string& name);
  void see (const std::string& type,
	    const std::string& scope, const std::string& id);
  void see_page (const std::string& scope, const std::string& id);

  // Create and Destroy.
  explicit FormatLaTeX (const AttributeList& al)
    : Format (al)
  { }
};

void 
FormatLaTeX::item_open (const std::string& name)
{
  out () << "\n\\item ";
  italic (name);
  text (": ");
}

void 
FormatLaTeX::item_close ()
{ }

void 
FormatLaTeX::section_open (const std::string& type, const std::string& title,
			   const std::string& scope, const std::string& label)
{
  out () << "\\" << type;
  out () << "{";
  text (title);
  out () << "}\n\\label{" << scope << ":";
  text (label);
  out () << "}\n";
}

void 
FormatLaTeX::section_close ()
{ }

void
FormatLaTeX::document_open ()
{ 
  out () << "\
%%% components.tex --- Description of Daisy components.\n\
%%%\n\
%%% This file is automatically generated, do not edit.\n"; 
}

void
FormatLaTeX::document_close ()
{ 
  const time_t now = time (NULL);
  out () << "\
\n\
\\chapter*{Version}\n\
\\label{version}\n\
\\addcontentsline{toc}{chapter}{\\numberline{}Version}\n\
\n\
Daisy version " << version << ".\\\\\n\
LaTeX manual generated: " << ctime (&now) << "\n\
\n\
%%% Local Variables:\n\
%%% mode: latex\n\
%%% TeX-master: \"reference\"\n\
%%% End:\n\
\n\
%%% components.tex ends here\n";
}

void
FormatLaTeX::text (const std::string& name)
{
  for (unsigned int i = 0; i < name.length (); i++)
    switch (name[i])
      {
      case '^':
	if (i+1 < name.length () && (isalnum (name[i+1]) || name[i+1] == '-'))
	  {
	    out () << "$" << name[i] << "{";
	    do
	      {
		out () << name[i+1];
		i++;
	      }
	    while (i+1 < name.length () && isalnum (name[i+1]));
	    out () << "}$";
	  }
	else
	  out () << "\\" << name[i] << "{ }";
	break;
      case '~':
	out () << "\\" << name[i] << "{ }";
	break;
      case '_':
      case '#':
      case '$':
      case '%':
      case '&':
      case '{':
      case '}':
	out () << "\\" << name[i];
	break;
      case '\\':
	out () << "\\mbox{$\\backslash$}";
	break;
      case '[':
      case ']':
      case '+':
      case '=':
      case '<':
      case '>':
	out () << "\\mbox{$" << name[i] << "$}";
	break;
      default:
	out () << name[i];
      }
}

void
FormatLaTeX::bold (const std::string& name)
{
  out () << "\\textbf{";
  text (name);
  out () << "}";
}

void
FormatLaTeX::italic (const std::string& name)
{
  out () << "\\textit{";
  text (name);
  out () << "}";
}

void
FormatLaTeX::verbatim (const std::string& name)
{
  out () << "\\begin{verbatim}\n";
  text (name);
  out () << "\\end{verbatim}\n";
}

void
FormatLaTeX::special (const std::string& name)
{
  static struct SymTable : public std::map<std::string, std::string>
  {
    SymTable ()
    {
      typedef std::pair<std::string,std::string> p;
      insert (p ("...", "\\ldots{}"));
      insert (p ("->", "$\\rightarrow$"));
      insert (p ("nbsp", "~"));
      insert (p ("daisy", "\\daisy{}"));
    }
  } sym_table;
  daisy_assert (sym_table.find (name) != sym_table.end ());
  out () << sym_table[name];
}

void
FormatLaTeX::soft_linebreak ()
{ out () << "\n"; }

void
FormatLaTeX::hard_linebreak ()
{ out () << "\\\\\n"; }

void
FormatLaTeX::new_paragraph ()
{ out () << "\n\n"; }

void
FormatLaTeX::index (const std::string& name)
{
  out () << "\\index{";
  text (name);
  out () << "}";
}

void
FormatLaTeX::see (const std::string& type,
		  const std::string& scope, const std::string& id)
{ out () << "(see " << type << "~\\ref{" << scope << ":" << id << "})"; }

void
FormatLaTeX::see_page (const std::string& scope, const std::string& id)
{
  out () << "(see \\ref{" << scope << ":" << id << "}, page \\pageref{"
	 << scope << ":" << id << "})";
}

static struct FormatLaTeXSyntax
{
  static Format& make (const AttributeList& al)
  { return *new FormatLaTeX (al); }
  FormatLaTeXSyntax ()
  {
    Syntax& syntax = *new Syntax ();
    AttributeList& alist = *new AttributeList ();
    alist.add ("description", "Format text as LaTeX.");
    Librarian<Format>::add_type ("LaTeX", alist, syntax, &make);
  }
} FormatLaTeX_syntax;
