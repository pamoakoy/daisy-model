// format_LaTeX.C --- LaTeX text formatting.
// 
// Copyright 2005 Per Abrahamsen and KVL.
//
// This file is part of Daisy.
// 
// Daisy is free software; you can redistribute it and/or modify
// it under the terms of the GNU Lesser Public License as published by
// the Free Software Foundation; either version 2.1 of the License, or
// (at your option) any later version.
// 
// Daisy is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser Public License for more details.
// 
// You should have received a copy of the GNU Lesser Public License
// along with Daisy; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA


#include "format_LaTeX.h"
#include "syntax.h"
#include "alist.h"
#include "version.h"
#include "assertion.h"
#include "librarian.h"
// GCC 2.95 lack ostream.
#include <iostream>
#include <map>
#include <time.h>

void
FormatLaTeX::list_open ()
{ 
  list_level++;
  if (list_level > 3)
    out () << "\\begin{enumerate}\n";
  else
    out () << "\\begin{itemize}\n";
}

void
FormatLaTeX::list_close ()
{ 
  if (list_level > 3)
    out () << "\\end{enumerate}\n";
  else
    out () << "\\end{itemize}\n";
  list_level--;
}

void 
FormatLaTeX::item_open (const std::string& name)
{
  out () << "\\item ";
  italic (name);
  text (": ");
}

void 
FormatLaTeX::item_close ()
{ }

void 
FormatLaTeX::table_open (const std::string& format)
{
  out () << "\\begin{tabular}{" << format << "}\n";
  table_first_row.push (true);
}

void 
FormatLaTeX::table_close ()
{
  out () << "\n\\end{tabular}\n";
  daisy_assert (!table_first_row.empty ());
  table_first_row.pop ();
}

void 
FormatLaTeX::table_row_open ()
{ 
  if (table_first_row.top ())
    table_first_row.top () = false;
  else
    out () << "\\\\\n";

  table_first_column.push (true);
}

void 
FormatLaTeX::table_row_close ()
{
  daisy_assert (!table_first_column.empty ());
  table_first_column.pop ();
}

void 
FormatLaTeX::table_cell_open ()
{
  if (table_first_column.top ())
    table_first_column.top () = false;
  else
    out () << "&";
}

void 
FormatLaTeX::table_cell_close ()
{ }

void 
FormatLaTeX::table_multi_cell_open (const int cells, const std::string& format)
{ 
  table_cell_open ();
  out () << "\\multicolumn{" << cells << "}{" << format <<"}{"; 
}

void
FormatLaTeX::table_multi_cell_close ()
{ out () << "}"; }

void
FormatLaTeX::typewriter_open ()
{ 
  out () << "\\begin{tt}\n";
}

void
FormatLaTeX::typewriter_close ()
{ 
  out () << "\\end{tt}\n";
}

void 
FormatLaTeX::section_open (const std::string& type, const std::string& title,
			   const std::string& scope, const std::string& label)
{
  out () << "\\" << type;
  out () << "{";
  text (title);
  out () << "}\n\\label{" << scope << ":" << label << "}\n";
}

void 
FormatLaTeX::section_close ()
{ }

void
FormatLaTeX::document_open ()
{ 
  out () << "\
%%% components.tex --- Description of Daisy components.\n\
%%%\n\
%%% This file is automatically generated, do not edit.\n"; 
}

void
FormatLaTeX::document_close ()
{ 
  const time_t now = time (NULL);
  out () << "\
\n\
\\chapter*{Version}\n\
\\label{version}\n\
\\addcontentsline{toc}{chapter}{\\numberline{}Version}\n\
\n\
Daisy version " << version << ".\\\\\n\
LaTeX manual generated: " << ctime (&now) << "\n\
\n\
%%% Local Variables:\n\
%%% mode: latex\n\
%%% TeX-master: \"reference\"\n\
%%% End:\n\
\n\
%%% components.tex ends here\n";
}

void
FormatLaTeX::text (const std::string& text)
{
  for (unsigned int i = 0; i < text.length (); i++)
    switch (text[i])
      {
      case '^':
	if (i+1 < text.length () && (isalnum (text[i+1]) || text[i+1] == '-'))
	  {
	    out () << "$" << text[i] << "{";
	    do
	      {
		out () << text[i+1];
		i++;
	      }
	    while (i+1 < text.length () && isalnum (text[i+1]));
	    out () << "}$";
	  }
	else
	  out () << "\\" << text[i] << "{ }";
	break;
      case '~':
	out () << "\\" << text[i] << "{ }";
	break;
      case '_':
      case '#':
      case '$':
      case '%':
      case '&':
      case '{':
      case '}':
	out () << "\\" << text[i];
	break;
      case '\\':
	out () << "$\\backslash$";
	break;
      case '[':
      case ']':
      case '+':
      case '=':
      case '<':
      case '>':
	out () << "$" << text[i] << "$";
	break;
      default:
	out () << text[i];
      }
}

void
FormatLaTeX::bold (const std::string& text)
{
  out () << "\\textbf{";
  this->text (text);
  out () << "}";
}

void
FormatLaTeX::italic (const std::string& text)
{
  out () << "\\textit{";
  this->text (text);
  out () << "}";
}

void
FormatLaTeX::verbatim (const std::string& text)
{
  out () << "\\begin{verbatim}\n";
  out () << text;
  out () << "\\end{verbatim}\n";
}

bool
FormatLaTeX::formatp (const std::string& format)
{ return format == "LaTeX"; }

void
FormatLaTeX::raw (const std::string& format, const std::string& text)
{
  daisy_assert (format == "LaTeX");
  out () << text;
}

void
FormatLaTeX::special (const std::string& name)
{
  static struct SymTable : public std::map<std::string, std::string>
  {
    SymTable ()
    {
      typedef std::pair<std::string,std::string> p;
      insert (p ("...", "\\ldots{}"));
      insert (p ("->", "$\\rightarrow $"));
      insert (p ("nbsp", "~"));
      insert (p ("daisy", "\\daisy{}"));
    }
  } sym_table;
  daisy_assert (sym_table.find (name) != sym_table.end ());
  out () << sym_table[name];
}

void
FormatLaTeX::soft_linebreak ()
{ out () << "\n"; }

void
FormatLaTeX::hard_linebreak ()
{ out () << "\\\\\n"; }

void
FormatLaTeX::new_paragraph ()
{ out () << "\n\n"; }

void
FormatLaTeX::index (const std::string& name)
{
  out () << "\\index{";
  text (name);
  out () << "}";
}

void
FormatLaTeX::label (const std::string& scope, const std::string& id)
{ out () << "\\label{" << scope << ":" << id << "}"; }

void
FormatLaTeX::pageref (const std::string& scope, const std::string& id)
{ out () << "\\pageref{" << scope << ":" << id << "}"; }

void
FormatLaTeX::ref (const std::string& scope, const std::string& id)
{ out () << "\\ref{" << scope << ":" << id << "}"; }

void
FormatLaTeX::see (const std::string& type,
		  const std::string& scope, const std::string& id)
{ out () << "(see " << type << "~\\ref{" << scope << ":" << id << "})"; }

void
FormatLaTeX::see_page (const std::string& scope, const std::string& id)
{
  out () << "(see ";
  ref (scope, id);
  out () << ", page ";
  pageref (scope, id);
  out () << ")";
}

FormatLaTeX::FormatLaTeX (Block& al)
  : Format (al),
    list_level (0)
{ }

static struct FormatLaTeXSyntax
{
  static Model& make (Block& al)
  { return *new FormatLaTeX (al); }
  FormatLaTeXSyntax ()
  {
    Syntax& syntax = *new Syntax ();
    AttributeList& alist = *new AttributeList ();
    alist.add ("description", "Format text as LaTeX.");
    Librarian::add_type (Format::component, "LaTeX", alist, syntax, &make);
  }
} FormatLaTeX_syntax;
