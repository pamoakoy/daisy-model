// weather_std.C --- Standard weather file.
// 
// Copyright 1996-2001 Per Abrahamsen and Søren Hansen
// Copyright 2000-2001 KVL.
//
// This file is part of Daisy.
// 
// Daisy is free software; you can redistribute it and/or modify
// it under the terms of the GNU Lesser Public License as published by
// the Free Software Foundation; either version 2.1 of the License, or
// (at your option) any later version.
// 
// Daisy is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser Public License for more details.
// 
// You should have received a copy of the GNU Lesser Public License
// along with Daisy; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

#define BUILD_DLL

#include "weather_base.h"
#include "chemical.h"
#include "alist.h"
#include "fao.h"
#include "lexer_data.h"
#include "time.h"
#include "plf.h"
#include <sstream>
#include "mathlib.h"
#include "units.h"
#include "submodeler.h"
#include "check.h"
#include "vcheck.h"
#include "memutils.h"
#include "librarian.h"
#include "path.h"
#include "treelog.h"
#include "frame_submodel.h"
#include <vector>
#include <algorithm>
#include <numeric>
#include <set>

struct WeatherStandard : public WeatherBase
{
  Path& path;

  // Units.
  static symbol N_deposit_unit ();
  static symbol fraction_unit ();
  static symbol hours_unit ();

  // Snow Model.
  const double T_rain;
  const double T_snow;

  // Missing years.
  struct YearMap
  {
    // Types.
    struct YearInterval
    {
      // Parameters.
      const int from;
      const int to;

      // Use.
      int size () const
      { return to - from + 1; }

      // Create and Destroy.
      static bool check_alist (const AttributeList& al, Treelog&);
      static void load_syntax (FrameSubmodel&);
      YearInterval (const AttributeList&);
    };

    // Parameters.
    const YearInterval from;
    const YearInterval to;

    // Use.
    bool contain (const Time& time) const;
    void map_time (Time& time) const;

    // Create and Destroy.
    static bool check_alist (const AttributeList& al, Treelog&);
    static void load_syntax (FrameSubmodel&);
    YearMap (Block&);
  };
  const auto_vector<const YearMap*> missing_years;
  int active_map;
  int find_map (const Time& time) const;

  // Keywords
  struct keyword_description_type
  {
    const char* name;
    const char* dim;
    double WeatherStandard::* value;
    double min;
    double max;
    bool required;
  };
  static keyword_description_type keyword_description[];
  static const int keyword_description_size;
  int timestep;
  Time begin;
  Time end;
  std::vector<double> precipitation_correction;

  // Extra parameters.
  std::vector<double> precipitation_scale;
  std::vector<double> temperature_scale;
  std::vector<double> temperature_offset;

  // Overwrite keywords.
  double CO2_;
  double CO2 () const //[Pa]
  { return CO2_; }

  // Data description.
  struct data_description_type
  {
    const char* name;
    const char* dim;
    double WeatherStandard::* value;
    symbol WeatherStandard::* read;
    double min;
    double max;
    bool required;
  };
  static data_description_type data_description[];
  static const int data_description_size;
  std::vector<int> data_index;
  bool has_data (const std::string& name);
  bool has_date;
  bool has_hour;
  bool has_temperature;
  bool has_min_temperature;
  bool has_max_temperature;
  bool has_vapor_pressure_;
  bool has_diffuse_radiation_;
  bool has_relative_humidity_;
  bool has_wind_speed;
  bool has_reference_evapotranspiration_;

  // Convertion.
  symbol air_temperature_read;
  symbol min_air_temperature_read;
  symbol max_air_temperature_read;
  symbol global_radiation_read;
  symbol precipitation_read;
  symbol vapor_pressure_read;
  symbol diffuse_radiation_read;
  symbol relative_humidity_read;
  symbol wind_speed_read;
  symbol reference_evapotranspiration_read;

  // Parsing.
  const symbol where;
  std::auto_ptr<std::istream> owned_stream;
  std::auto_ptr<LexerData> lex;
  Lexer::Position end_of_header;

  // These are the last read values for today.
  Time last_time;
  double last_air_temperature;
  double last_min_air_temperature;
  double last_max_air_temperature;
  double last_global_radiation;
  double last_precipitation;
  double last_vapor_pressure;
  double last_diffuse_radiation;
  double last_relative_humidity;
  double last_wind_speed;
  double last_reference_evapotranspiration;

  // And for yesterday.
  double yesterday_T_max;

  // These are the first values after today.
  bool initialized;
  Time next_time;
  double next_year;
  double next_month;
  double next_day;
  double next_hour;
  double next_air_temperature;
  double next_min_air_temperature;
  double next_max_air_temperature;
  double next_global_radiation;
  double next_precipitation;
  double next_vapor_pressure;
  double next_diffuse_radiation;
  double next_relative_humidity;
  double next_wind_speed;
  double next_reference_evapotranspiration;

  // Data.
  int hour;
  double air_temperature_[24];
  double global_radiation_[24];
  double precipitation_[24];
  double vapor_pressure_[24];
  double diffuse_radiation_[24];
  double relative_humidity_[24];
  double wind_speed_[24];
  double reference_evapotranspiration_[24];

  // Daily averages.
  double daily_air_temperature_;
  double daily_max_air_temperature_;
  double daily_min_air_temperature_;
  double daily_global_radiation_;
  double daily_precipitation_;

  // Fractions this hour.
  double snow_fraction;
  double rain_fraction;

  // Simulation.
  void tick (const Time& time, Treelog&);
  void output (Log& log) const
  { WeatherBase::output (log); }
  void read_line ();
  void read_new_day (const Time&, Treelog&);

  // Communication with Bioclimate.
  double air_temperature () const // [dg C]
  { 
    daisy_assert (initialized);
    return air_temperature_[hour]; 
  }
  double daily_air_temperature () const // [dg C]
  { 
    daisy_assert (initialized);
    return daily_air_temperature_; 
  }
  double daily_max_air_temperature () const // [dg C]
  { 
    daisy_assert (initialized);
    return daily_max_air_temperature_; 
  }
  double daily_min_air_temperature () const // [dg C]
  { 
    daisy_assert (initialized);
    return daily_min_air_temperature_; 
  }
  double global_radiation () const // [W/m2]
  { 
    daisy_assert (initialized);
    return global_radiation_[hour]; 
  }
  double daily_global_radiation () const // [W/m2]
  { 
    daisy_assert (initialized);
    return daily_global_radiation_; 
  }
  double reference_evapotranspiration () const // [mm/h]
  { 
    daisy_assert (initialized);
    return reference_evapotranspiration_[hour]; 
  }
  double daily_precipitation () const // [mm/d]
  {
    daisy_assert (initialized);
    return daily_precipitation_;
  }
  double rain () const	// [mm/h]
  { 
    daisy_assert (initialized);
    return precipitation_[hour] * rain_fraction; 
  }
  double snow () const	// [mm/h]
  { 
    daisy_assert (initialized);
    return precipitation_[hour] * snow_fraction; 
  }
  double vapor_pressure () const // [Pa]
  { 
    daisy_assert (initialized);
    return vapor_pressure_[hour]; 
  }
  double diffuse_radiation () const // [W/m2]
  { 
    daisy_assert (initialized);
    return diffuse_radiation_[hour]; 
  }
  double relative_humidity () const // []
  { 
    daisy_assert (initialized);
    return relative_humidity_[hour]; 
  }
  double wind () const	// [m/s]
  { 
    daisy_assert (initialized);
    return wind_speed_[hour]; 
  }

  bool has_reference_evapotranspiration () const
  { return has_reference_evapotranspiration_; }

  bool has_vapor_pressure () const
  { return has_vapor_pressure_ || has_relative_humidity_; }

  bool has_diffuse_radiation () const
  { return has_diffuse_radiation_; }

  bool has_relative_humidity () const
  { return has_relative_humidity_; }

  bool has_wind () const
  { return has_wind_speed; }

  bool has_min_max_temperature () const
  { return has_min_temperature && has_max_temperature; }

  // Create and Destroy.
  bool initialize (const Time& time, Treelog& err);
  WeatherStandard (Block&);
  ~WeatherStandard ();
  bool check (const Time& from, const Time& to, Treelog& err) const;
};

bool
WeatherStandard::YearMap::YearInterval::check_alist (const AttributeList& al,
						     Treelog& err)
{
  bool ok = true;

  const int from = al.integer ("from");
  const int to = al.integer ("to");
  if (from > to)
    {
      std::ostringstream tmp;
      tmp << "Start year " << from << " comes after end year " << to;
      err.error (tmp.str ());
      ok = false;
    }
  return ok;
}

symbol 
WeatherStandard::N_deposit_unit ()
{
  static const symbol unit ("kgN/ha/year");
  return unit;
}

symbol 
WeatherStandard::fraction_unit ()
{
  static const symbol unit ("fraction");
  return unit;
}

symbol 
WeatherStandard::hours_unit ()
{
  static const symbol unit ("hours");
  return unit;
}

void 
WeatherStandard::YearMap::YearInterval::load_syntax (FrameSubmodel& frame)
{
  frame.add_check (check_alist);
  frame.add ("from", Value::Integer, Value::Const,
	      "First year of interval.");
  frame.add_check ("from", VCheck::valid_year ());
  frame.add ("to", Value::Integer, Value::Const,
	      "First year of interval.");
  frame.add_check ("to", VCheck::valid_year ());
  frame.order ("from", "to");
}

WeatherStandard::YearMap::YearInterval::YearInterval (const AttributeList& al)
  : from (al.integer ("from")),
    to (al.integer ("to"))
{ }
    
bool WeatherStandard::YearMap::contain (const Time& time) const
{
  const int year = time.year ();
  return from.from <= year && year <= from.to;
}

void WeatherStandard::YearMap::map_time (Time& time) const
{ time.tick_year (to.from - from.from); }

bool
WeatherStandard::YearMap::check_alist (const AttributeList& al, Treelog& msg)
{
  bool ok = true;
  const YearInterval from (al.alist ("from"));
  const YearInterval to (al.alist ("to"));
  
  if (from.size () != to.size ())
    {
      std::ostringstream tmp;
      tmp << "You cannot map " << from.size () << " years to "
	     << to.size () << " years";
      msg.error (tmp.str ());
      ok = false;
    }
  return ok;
}

void 
WeatherStandard::YearMap::load_syntax (FrameSubmodel& frame)
{ 
  frame.add_check (check_alist);
  frame.add_submodule ("from", Value::Const, 
			"Interval of years to map from.",
			YearInterval::load_syntax);
  frame.add_submodule ("to", Value::Const, 
			"Interval of years to map to.",
			YearInterval::load_syntax);
  frame.order ("from", "to");
}

WeatherStandard::YearMap::YearMap (Block& al)
  : from (al.alist ("from")),
    to (al.alist ("to"))
{ }

int 
WeatherStandard::find_map (const Time& time) const
{ 
  for (int i = 0; i < missing_years.size (); i++)
    if (missing_years[i]->contain (time))
      return i;
  return -1;
}

WeatherStandard::keyword_description_type 
WeatherStandard::keyword_description[] =
  { { "Latitude", "dgNorth", &WeatherStandard::latitude_, -90, 90, true },
    { "Longitude", "dgEast", &WeatherStandard::longitude_, -360, 360, true },
    { "Elevation", "m", &WeatherStandard::elevation_, 0, 10000, true },
    { "TimeZone", "dgEast", &WeatherStandard::timezone_, -360, 360, true },
    { "ScreenHeight", "m", &WeatherStandard::screen_height_, 0, 100, true },
    { "TAverage", "dgC", &WeatherStandard::T_average, -10, 40, true },
    { "TAmplitude", "dgC", &WeatherStandard::T_amplitude, 0, 100, true },
    { "MaxTDay", "yday", &WeatherStandard::max_Ta_yday, 1, 365, true } };

const int 
WeatherStandard::keyword_description_size 
/**/ = sizeof (WeatherStandard::keyword_description) 
  /**/ / sizeof (keyword_description_type);

WeatherStandard::data_description_type 
WeatherStandard::data_description[] =
  { { "Year", "year", &WeatherStandard::next_year, NULL,
      1, 9999, false },
    { "Month", "month", &WeatherStandard::next_month, NULL,
      1, 12, false },
    { "Day", "mday", &WeatherStandard::next_day, NULL,
      1, 31, false },
    { "Hour", "hour", &WeatherStandard::next_hour, NULL,
      0, 23, false },
    { "GlobRad", "W/m^2", &WeatherStandard::next_global_radiation,
      &WeatherStandard::global_radiation_read,
      0, 1400, true },
    { "AirTemp", "dgC", &WeatherStandard::next_air_temperature,
      &WeatherStandard::air_temperature_read,
      -70, 60, false },
    { "T_min", "dgC", &WeatherStandard::next_min_air_temperature,
      &WeatherStandard::min_air_temperature_read,
      -70, 60, false },
    { "T_max", "dgC", &WeatherStandard::next_max_air_temperature,
      &WeatherStandard::max_air_temperature_read,
      -70, 60, false },
    { "Precip", "mm/h", &WeatherStandard::next_precipitation,
      &WeatherStandard::precipitation_read,
      0, 300, true },
    { "RefEvap", "mm/h", &WeatherStandard::next_reference_evapotranspiration,
      &WeatherStandard::reference_evapotranspiration_read,
      -10, 20, false },
    { "VapPres", "Pa", &WeatherStandard::next_vapor_pressure,
      &WeatherStandard::vapor_pressure_read,
      0, 5000, false },
    { "DiffRad", "W/m^2", &WeatherStandard::next_diffuse_radiation,
      &WeatherStandard::diffuse_radiation_read,
      0, 1400, false },
    { "RelHum", "fraction", &WeatherStandard::next_relative_humidity,
      &WeatherStandard::relative_humidity_read,
      0, 5000, false },
    { "Wind", "m/s", &WeatherStandard::next_wind_speed,
      &WeatherStandard::wind_speed_read,
      0, 40, false } };

const int 
WeatherStandard::data_description_size 
/**/ = sizeof (WeatherStandard::data_description) 
  /**/ / sizeof (data_description_type);

bool
WeatherStandard::has_data (const std::string& name)
{
  for (unsigned int i = 0; i < data_index.size (); i++)
    {
      int index = data_index[i];
      if (index >= 0 && name == data_description[index].name)
	return true;
    }
  return false;
}

void
WeatherStandard::tick (const Time& time, Treelog& msg)
{
  Treelog::Open nest (msg, "Weather: " + name);

  WeatherBase::tick (time, msg);

  hour = time.hour ();
  
  if (hour == 0)
    read_new_day (time, msg);
  else if (!initialized)
    {
      Time midnight (time.year (), time.month (), time.mday (), 0);
      read_new_day (midnight, msg);
    }

  // Snow and rain fractions.
  const double T = air_temperature ();
  if (T < T_snow)
    {
      snow_fraction = 1.0;
      rain_fraction = 0.0;
    }
  else if (T_rain < T)
    {
      snow_fraction = 0.0;
      rain_fraction = 1.0;
    }
  else
    {
      snow_fraction = (T_rain - T) / (T_rain - T_snow);
      rain_fraction = 1.0 - snow_fraction;
    }
  daisy_assert (rain_fraction >= 0 && rain_fraction <= 1);
  daisy_assert (snow_fraction >= 0 && snow_fraction <= 1);
  daisy_assert (approximate (rain_fraction + snow_fraction, 1.0));

  WeatherBase::tick_after (time, msg);
}

void 
WeatherStandard::read_line ()
{
  daisy_assert (lex.get ());

  if (!lex->good ())
    {
      next_time.tick_hour ();
      return;
    }

  // Remember old values.
  last_time = next_time;
  last_air_temperature = next_air_temperature;
  last_min_air_temperature = next_min_air_temperature;
  last_max_air_temperature = next_max_air_temperature;
  last_global_radiation = next_global_radiation;
  last_precipitation = next_precipitation;
  last_vapor_pressure = next_vapor_pressure;
  last_diffuse_radiation = next_diffuse_radiation;
  last_relative_humidity = next_relative_humidity;
  last_wind_speed = next_wind_speed;
  last_reference_evapotranspiration = next_reference_evapotranspiration;

  while (true)
    {
      // Read new values.
      for (unsigned int i = 0; i < data_index.size (); i++)
	{
	  lex->skip_space ();
	  const int index = data_index[i];
	  if (index < 0)
	    continue;
	  const symbol dim (data_description[index].dim);
	  const symbol read = data_description[index].read
            ? this->*(data_description[index].read)
            : dim;
	  const double value =  units.convert (read, dim, lex->get_number ());
	  this->*(data_description[index].value) = value;
	  if (value < data_description[index].min)
	    lex->error (std::string ("Column ") 
                        + data_description[index].name + " value too low");
	  else if (value > data_description[index].max)
	    lex->error (std::string ("Column ") 
                        + data_description[index].name + " value too hight");
	  if (next_precipitation < 0.0)
	    next_precipitation = 0.0;
	  if (!lex->good ())
	    {
	      lex->error ("No more climate data, reusing last values");
	      return;
	    }
	}
      
      // Update time.
      if (timestep > 0)
	next_time.tick_hour (timestep);
      if (has_date)
	{
	  const int year = double2int (next_year);
	  const int month = double2int (next_month);
	  const int mday = double2int (next_day);
	  const int hour = has_hour 
	    ? double2int (next_hour) : next_time.hour ();

	  if (!Time::valid (year, month, mday, hour))
	    {
	      lex->error ("Invalid date");
	      lex->next_line ();
	      continue;
	    }
	  if (next_time != Time (year, month, mday, hour))
	    {
              if (timestep > 0)
                lex->error ("Bad timestep");
	      next_time = Time (year, month, mday, hour);
	    }
	}
      break;
    }

  if (has_min_temperature && has_max_temperature
      && next_min_air_temperature > next_max_air_temperature)
    lex->warning ("T_min > T_max");
  if (has_diffuse_radiation_
      && next_diffuse_radiation > next_global_radiation)
    lex->warning ("DiffRad > GlobRad");
  if (has_min_temperature && has_temperature
      && next_min_air_temperature > next_air_temperature)
    lex->warning ("T_min > AirTemp");
  if (has_temperature && has_max_temperature
      && next_air_temperature > next_max_air_temperature)
    lex->warning ("AirTemp > T_max");
  
  lex->next_line ();

  if (!lex->good ())
    {
      lex->error ("End of climate data, reusing last values");
      return;
    }

  // Monthly corrections and scaling.
  const int month = double2int (next_time.month ());
  next_precipitation *= precipitation_correction[month-1]
    * precipitation_scale[month-1];
  next_air_temperature *= temperature_scale[month-1];
  next_air_temperature += temperature_offset[month-1];
  next_min_air_temperature *= temperature_scale[month-1];
  next_min_air_temperature += temperature_offset[month-1];
  next_max_air_temperature *= temperature_scale[month-1];
  next_max_air_temperature += temperature_offset[month-1];

}

void 
WeatherStandard::read_new_day (const Time& time, Treelog& msg)
{ 
  daisy_assert (lex.get ());
  daisy_assert (time.hour () == 0);

  // Handle missing years.
  bool find_new_map = false;
  if (active_map >= 0)
    {
      if (time.between (begin, end))
	{
	  msg.message ("Using current data");
	  active_map = -1;
	  initialized = false;
	}
      else if (!missing_years[active_map]->contain (time))
	find_new_map = true;
    }
  else if (!time.between (begin, end))
    find_new_map = true;

  if (find_new_map)
    {
      active_map = find_map (time);
      if (active_map >= 0)
	{
	  std::ostringstream tmp;
	  tmp << "Using data from [" << missing_years[active_map]->to.from
		 << "-" << missing_years[active_map]->to.to << "] for years ["
		 << missing_years[active_map]->from.from << "-"
		 << missing_years[active_map]->from.to << "]";
	  msg.message (tmp.str ());
	  initialized = false;
	}
    }

  // Initialize.
  if (!initialized)
    {
      initialized = true;
      lex->seek (end_of_header);
      next_time = begin;
      if (timestep > 0)
        next_time.tick_hour (-timestep);
      else
        next_time.tick_hour (-24);
      read_line ();
    }
  
  // Now.
  Time now = time;
  if (active_map >= 0)
    {
      missing_years[active_map]->map_time (now);
      if (!now.between (begin, end))
        {
	  std::ostringstream tmp;
	  tmp << "No mapped weather data for " << now.year () 
		 << "-" << now.month ()
		 << "-" << now.mday () << ":" << now.hour ();
	  msg.error (tmp.str ());
          now = time;
        }
    }
  if (!now.between (begin, end))
    {
      std::ostringstream tmp;
      tmp << "No weather data for " << time.year () 
             << "-" << time.month ()
             << "-" << time.mday () << ":" << time.hour ()
             << "\nReusing yesterdays data.";
      msg.error (tmp.str ());
      return;
    }

  // Tomorrow.
  Time tomorrow = now;
  tomorrow.tick_day ();

  // BC5 sucks // while (next_time <= now)
  while (!(now < next_time))
    read_line ();

  bool long_timestep;
  while (true)
    {
      Time end = (next_time < tomorrow) ? next_time : tomorrow;

      const int hours = Time::hours_between (last_time, next_time);
      long_timestep = (hours > 12);
      for (;now < end; now.tick_hour ())
	{
	  int hour = now.hour ();
	  if (has_min_temperature && has_max_temperature)
            {
              if (long_timestep)
                {
                  if (yesterday_T_max < -400.0)
                    // First time.
                    yesterday_T_max = last_max_air_temperature;

                  const double t_min = 12.0 - day_length () / 2.0;
                  const double t_max = 15.0;
                  PLF T;
                  T.add (15 - 24.0, yesterday_T_max);
                  T.add (t_min, last_min_air_temperature);
                  T.add (t_max, last_max_air_temperature);
                  T.add (24.0 + t_min, next_min_air_temperature);
                  air_temperature_[hour] = T (hour);
                  yesterday_T_max = last_max_air_temperature;
                }
              else if (has_temperature)
                air_temperature_[hour] = last_air_temperature;
              else
                air_temperature_[hour] = (last_min_air_temperature 
                                          + last_max_air_temperature) / 2.0;
            }
	  else if (has_temperature)
	    air_temperature_[hour] = last_air_temperature;
          else 
	    air_temperature_[hour] = T_normal (now);
	  global_radiation_[hour] = last_global_radiation;
	  if (long_timestep)
	    global_radiation_[hour] *= day_cycle (now) * 24.0;
	  if (has_diffuse_radiation_)
	    {
	      diffuse_radiation_[hour] = last_diffuse_radiation;
	      if (long_timestep)
		diffuse_radiation_[hour] *= day_cycle (now) * 24.0;
	    }
	  else 
	    diffuse_radiation_[hour] = 0.0;
	    
	  precipitation_[hour] = last_precipitation;
	  if (has_vapor_pressure_)
	    vapor_pressure_[hour] = last_vapor_pressure;
	  else if (has_relative_humidity_)
	    vapor_pressure_[hour] 
	      = FAO::SaturationVapourPressure (air_temperature_[hour])
	      * last_relative_humidity;
	  if (has_wind_speed)
	    wind_speed_[hour] = last_wind_speed;
	  else
	    wind_speed_[hour] = 3.0;
	  if (has_relative_humidity_)
	    relative_humidity_[hour] = last_relative_humidity;
          else if (has_vapor_pressure_)
	    {
	      relative_humidity_[hour] = last_vapor_pressure / 
		FAO::SaturationVapourPressure (air_temperature_[hour]);
#if 0
	      if (relative_humidity_[hour] < 0.0 
		  ||relative_humidity_[hour] > 1.0)
		{
		  std::ostringstream tmp;
		  tmp << "RelHum[" << hour << "] = " << relative_humidity_[hour] 
		      << " [] because VapPres = " << last_vapor_pressure
		      << " [Pa] and T = " << air_temperature_[hour]
		      << " [dg C], giving Sat. VapPres = " 
		      << FAO::SaturationVapourPressure (air_temperature_[hour])
		      << " [Pa]";
		  lex->warning (tmp.str ());
		}
#endif
	    }
	  if (has_reference_evapotranspiration_)
	    {
	      reference_evapotranspiration_[hour] 
		= last_reference_evapotranspiration;
	      if (long_timestep)
		reference_evapotranspiration_[hour] *= day_cycle (now) * 24.0;
	    }
	  else
	    reference_evapotranspiration_[hour] 
	      = FAO::Makkink (air_temperature_[hour], global_radiation_[hour]);
	}
      // BC5 sucks // if (next_time >= tomorrow)
      if (!(next_time < tomorrow))
	break;
      read_line ();
    }

  daily_precipitation_
    = long_timestep
    ? last_precipitation * 24
    : std::accumulate (&precipitation_[0], &precipitation_[24], 0.0);
  daily_global_radiation_ 
    = long_timestep
    ? last_global_radiation
    : std::accumulate (&global_radiation_[0], &global_radiation_[24], 0.0) / 24.0;
  daily_air_temperature_
    = (long_timestep && has_temperature)
    ? last_air_temperature
    : std::accumulate (&air_temperature_[0], &air_temperature_[24], 0.0) / 24.0;
  daily_max_air_temperature_
    = has_max_temperature 
    ? last_max_air_temperature
    : *std::max_element (&air_temperature_[0], &air_temperature_[24]);
  daily_min_air_temperature_
    = has_min_temperature 
    ? last_min_air_temperature
    : *std::min_element (&air_temperature_[0], &air_temperature_[24]);

  if (!has_vapor_pressure_ && !has_relative_humidity_)
    {
      double T_min = daily_min_air_temperature_;
      const double T_max = daily_max_air_temperature_;
      if (T_min + 0.001 >= T_max)
	T_min -= 5.0;
      const double VapMin = FAO::SaturationVapourPressure (T_min);
      for (int hour = 0; hour < 24; hour++)
	{
	  vapor_pressure_[hour] = VapMin;
	  relative_humidity_[hour]
	    = VapMin / FAO::SaturationVapourPressure (air_temperature_[hour]);
	}
    }
}

bool
WeatherStandard::initialize (const Time& time, Treelog& msg)
{ 
  Treelog::Open nest (msg, "Weather: " + name);

  daisy_assert (!owned_stream.get ());
  owned_stream = path.open_file (where);
  daisy_assert (!lex.get ());
  lex.reset (new LexerData (where, *owned_stream, msg));
  daisy_assert (lex.get ());
  // Open errors?
  if (!lex->good ())
    return false;

  // Units.
  const Unit& u_ppm = units.get_unit (Units::ppm ());
  const Unit& u_dpu = units.get_unit (Weather::dry_deposit_unit ());

  // Read first line.
  const std::string type = lex->get_word ();
  if (type != "dwf-0.0")
    lex->error ("Wrong file type");
  lex->skip_line ();
  lex->next_line ();

  std::set<std::string/**/> keywords;

  struct Deposition
  {
    double total;
    double dry;
    double dry_NH4;
    double wet_NH4;
    double precipitation;
    Deposition ()
      : total (-42.42e42),
        dry (0.4),
        dry_NH4 (0.6),
        wet_NH4 (0.5),
        precipitation (-42.42e42)
    { }
  } deposition;

  // Read keywords.
  bool last_was_note = false;
  while (lex->good () && lex->peek () != '-')
    {
      std::string key = lex->get_word ();

      if (key.size () < 1)
        {
	  lex->error ("Empty keyword");
	  lex->skip_line ();
	  lex->next_line ();
	  continue;
        }
      if (key[key.size () - 1] != ':')
	{
	  lex->error ("Keywords should end in :");
	  lex->skip_line ();
	  lex->next_line ();
	  continue;
	}
      key = key.substr (0, key.size () - 1);

      if (keywords.find (key) == keywords.end ())
	keywords.insert (key);
      else if (key != "Note")
	lex->error (std::string ("Duplicate keyword '") + key + "'");
      else if (!last_was_note)
	lex->error ("Only one Note: block allowed");
      
      last_was_note = false;
		   
      if (key == "Station")
	lex->skip_line ();
      else if (key == "Note")
	{
	  lex->skip_line ();
	  last_was_note = true;
	}
      else if (key == "Surface")
	{
	  lex->skip_space ();
	  const std::string type = lex->get_word ();
	  if (type == "reference")
	    surface_ = reference;
	  else if (type == "field")
	    surface_ = field;
	  else
	    lex->error ("Uknown surface type");
	}
      else if (key == "PrecipCorrect")
	{
	  for (unsigned int i = 0; i < 12; i++)
	    {
	      lex->skip_space ();
	      const double val = lex->get_number ();
	      if (val < 0.5)
		lex->warning ("Unreasonable low value");
	      else if (val > 1.8)
		lex->warning ("Unreasonable high value");
	      precipitation_correction[i] = val;
	    }
	}
      else if (key == "Begin")
	{
	  lex->skip_space ();
	  lex->read_date (begin);
	}
      else if (key == "End")
	{
	  lex->skip_space ();
	  lex->read_date (end);
          end.tick_day (-2);
	}
      else
	{
	  lex->skip_space ();
	  double val = lex->get_number ();
	  lex->skip_space ();
	  const symbol dim (lex->get_word ());
	      
	  if (key == "NH4WetDep")
	    {
	      if (units.can_convert (dim, Units::ppm (), msg))
		val = units.convert (dim, Units::ppm (), val);
	      else
		lex->error ("Unknown dimension");
	      if (val < 0.0 || val > 100.0)
		lex->error ("Unreasonable value");
	      WetDeposit.set_value (Chemical::NH4 (),
				    u_ppm, val);
	    }
	  else if (key == "NH4DryDep")
	    {
	      if (units.can_convert (dim, N_deposit_unit (), msg))
		val = units.convert (dim, N_deposit_unit (), val);
	      else
		lex->error ("Unknown dimension");
	      if (val < 0.0 || val > 100.0)
		lex->error ("Unreasonable value");
	      DryDeposit.set_value (Chemical::NH4 (), u_dpu, val);
	    }
	  else if (key == "NO3WetDep")
	    {
	      if (units.can_convert (dim, Units::ppm (), msg))
		val = units.convert (dim, Units::ppm (), val);
	      else
		lex->error ("Unknown dimension");
	      if (val < 0.0 || val > 100.0)
		lex->error ("Unreasonable value");
	      WetDeposit.set_value (Chemical::NO3 (), u_ppm, val);
	    }
	  else if (key == "NO3DryDep")
	    {
	      if (units.can_convert (dim, N_deposit_unit (), msg))
		val = units.convert (dim, N_deposit_unit (), val);
	      else
		lex->error ("Unknown dimension");
	      if (val < 0.0 || val > 100.0)
		lex->error ("Unreasonable value");
	      DryDeposit.set_value (Chemical::NO3 (), u_dpu, val);
	    }
          // Alternative way of specifying deposition.
	  else if (key == "Deposition")
	    {
	      if (units.can_convert (dim, N_deposit_unit (), msg))
		val = units.convert (dim, N_deposit_unit (), val);
	      else
		lex->error ("Unknown dimension");
	      if (val < 0.0 || val > 100.0)
		lex->error ("Unreasonable value");
	      deposition.total = val;
	    }
	  else if (key == "DepDry")
	    {
	      if (units.can_convert (dim, fraction_unit (), msg))
		val = units.convert (dim, fraction_unit (), val);
	      else
		lex->error ("Unknown dimension");
	      if (val < 0.0 || val > 1.0)
		lex->error ("Unreasonable value");
	      deposition.dry = val;
	    }
	  else if (key == "DepDryNH4")
	    {
	      if (units.can_convert (dim, fraction_unit (), msg))
		val = units.convert (dim, fraction_unit (), val);
	      else
		lex->error ("Unknown dimension");
	      if (val < 0.0 || val > 1.0)
		lex->error ("Unreasonable value");
	      deposition.dry_NH4 = val;
	    }
	  else if (key == "DepWetNH4")
	    {
	      if (units.can_convert (dim, fraction_unit (), msg))
		val = units.convert (dim, fraction_unit (), val);
	      else
		lex->error ("Unknown dimension");
	      if (val < 0.0 || val > 1.0)
		lex->error ("Unreasonable value");
	      deposition.wet_NH4 = val;
	    }
	  else if (key == "PAverage")
	    {
	      if (units.can_convert (dim, Units::mm (), msg))
		val = units.convert (dim, Units::mm (), val);
	      else
		lex->error ("Unknown dimension");
	      if (val < 0.0 || val > 3000.0)
		lex->error ("Unreasonable value");
	      deposition.precipitation = val;
	    }
	  else if (key == "Timestep")
	    {
	      if (units.can_convert (dim, hours_unit (), msg))
		val = units.convert (dim, hours_unit (), val);
	      else
		lex->error ("Unknown dimension");
	      timestep = double2int (val);
	      if (!approximate (timestep, val) || timestep < 0.0)
		lex->error ("Timestep should be a cardinal number");
	    }
	  else
	    {
	      bool found = false;
	      for (unsigned int i = 0; i < keyword_description_size; i++)
		{
		  if (key == keyword_description[i].name)
		    {
		      if (units.can_convert (dim, symbol (keyword_description[i].dim), msg))
			val = units.convert (dim, symbol (keyword_description[i].dim),
                                             val);
		      else
			lex->error ("Unknown dimension");
		      if (val < keyword_description[i].min)
			lex->error (key + " value too low");
		      else if (val > keyword_description[i].max)
			lex->error (key + " value too high");
		      this->*(keyword_description[i].value) = val;
		      found = true;
		    }
		}
	      if (!found)
		lex->error (std::string ("Unknown keyword: '") + key + "'");
	    }
	}
      lex->next_line ();
    }

  // Check keywords.
  for (unsigned int i = 0; i < keyword_description_size; i++)
    if (keyword_description[i].required 
	&& keywords.find (keyword_description[i].name) == keywords.end ())
      lex->error (std::string ("Keyword ") 
                  + keyword_description[i].name + " missing");

  static const std::string required[] = 
    { "Station", "Surface", "Begin", "End" };
  static const int required_size = sizeof (required) / sizeof (std::string);
  
  for (unsigned int i = 0; i < required_size; i++)
    if (keywords.find (required[i]) == keywords.end ())
      lex->error (std::string ("Missing keyword '") + required[i] + "'");

  static const std::string dep1[] = 
    { "NH4WetDep", "NO3WetDep", "NH4DryDep", "NO3DryDep" };
  static const int dep1_size = sizeof (dep1) / sizeof (std::string);

  bool dep1_has_all = true;
  bool dep1_has_any = false;
  for (unsigned int i = 0; i < dep1_size; i++)
    if (keywords.find (dep1[i]) == keywords.end ())
      dep1_has_all = false;
    else
      dep1_has_any = true;
  daisy_assert (dep1_has_any || !dep1_has_all);
  
  static const std::string dep2[] = 
    { "Deposition", "PAverage" };
  static const int dep2_size = sizeof (dep2) / sizeof (std::string);

  bool dep2_has_all = true;
  bool dep2_has_any = false;
  for (unsigned int i = 0; i < dep2_size; i++)
    if (keywords.find (dep2[i]) == keywords.end ())
      dep2_has_all = false;
    else
      dep2_has_any = true;
  daisy_assert (dep2_has_any || !dep2_has_all);

  if ((dep1_has_any && dep2_has_any)
      || (!dep1_has_all && !dep2_has_all))
    {
      lex->error ("\
You must specify either all of 'NH4WetDep', 'NO3WetDep', 'NH4DryDep',\n\
and 'NO3DryDep'; or alternatively all of 'Deposition' and 'PAverage',\n\
but not both");
    }
  else if (dep1_has_all)
    daisy_assert (!dep2_has_any);
  else
    {
      daisy_assert (!dep1_has_any);
      const double dry = deposition.total * deposition.dry;
      const double wet = deposition.total * (1.0 - deposition.dry);
      daisy_assert (approximate (dry + wet, deposition.total));
      DryDeposit.set_value (Chemical::NH4 (), u_dpu, dry * deposition.dry_NH4);
      DryDeposit.set_value (Chemical::NO3 (), u_dpu,
			    dry * (1.0 - deposition.dry_NH4));
      WetDeposit.set_value (Chemical::NH4 (), u_ppm, 
                            wet * 100.0 * deposition.wet_NH4 
			    / deposition.precipitation);
      WetDeposit.set_value (Chemical::NO3 (), u_ppm, 
			    wet * 100.0 * (1.0 - deposition.wet_NH4)
			    / deposition.precipitation);
      std::ostringstream tmp;
      tmp << "NH4WetDep: " 
	  << WetDeposit.get_value (Chemical::NH4 (), u_ppm) << " ppm\n\
NH4DryDep: " 
	  << DryDeposit.get_value (Chemical::NH4 (), u_dpu) << " kgN/ha/year\n\
NO3WetDep: " << WetDeposit.get_value (Chemical::NO3 (), u_ppm) << " ppm\n\
NO3DryDep: " << DryDeposit.get_value (Chemical::NO3 (), u_dpu) 
          << " kgN/ha/year";
      msg.debug (tmp.str ());
    }

  // BC5 sucks // if (begin >= end)
  if (!(begin < end))
    lex->error ("Weather data ends before they begin");

  lex->skip_hyphens ();

  // Columns
  do
    {
      const std::string column = lex->get_word ();
      bool found = false;
      for (unsigned int j = 0; j < data_description_size; j++)
	if (column == data_description[j].name)
	  {
	    data_index.push_back (j);
	    found = true;
	    break;
	  }
      if (!found)
	{
	  data_index.push_back (-1);
	  lex->error (std::string ("Unknown column ") + column);
	}
      lex->skip_space ();
    }
  while (lex->good () && lex->peek () != '\n');
  lex->next_line ();

  has_date = (has_data ("Year") && has_data ("Month") && has_data ("Day"));
  has_hour = (has_date && has_data ("Hour"));
  if (!has_date && (has_data ("Year")
		    || has_data ("Month")
		    || has_data ("Day")))
    lex->error ("You should specify all of Year, Month and Day, or none");
  if (timestep < 1 && !has_date)
    lex->error ("You must specify either a timestep or date");
  has_temperature = has_data ("AirTemp");
  has_min_temperature = has_data ("T_min");
  has_max_temperature = has_data ("T_max");
  has_vapor_pressure_ = has_data ("VapPres");
  has_diffuse_radiation_ = has_data ("DiffRad");
  if (has_diffuse_radiation_ && timestep > 3)
    lex->warning ("You should not specify DiffRad with long timesteps");
  has_relative_humidity_ = has_data ("RelHum");
  if (has_relative_humidity_ && has_vapor_pressure_)
    lex->error ("You should only specify one of VapPres or RelHum");
  if (has_relative_humidity_ && timestep > 6)
    lex->warning ("You should not specify RelHum with long timesteps");
  has_wind_speed = has_data ("Wind");
  has_reference_evapotranspiration_ = has_data ("RefEvap");
  for (unsigned int j = 0; j < data_description_size; j++)
    if (data_description[j].required && !has_data (data_description[j].name))
      lex->error (std::string ("Required data column '") 
                  + data_description[j].name + "' missing");

  // Dimensions.
  for (unsigned int i = 0; i < data_index.size (); i++)
    {
      const symbol dimension (lex->get_word ());
      const int index = data_index[i];
      if (units.can_convert (dimension, symbol (data_description[index].dim)))
	{
	  if (data_description[index].read)
	    this->*(data_description[index].read) = dimension;
	}
      else
	lex->error ("Bad unit");

      lex->skip_space ();
    }
  lex->next_line ();

  // Start of data.
  end_of_header = lex->position ();

  // Start reading.
  Time previous (time);
  previous.tick_hour (-1);
  tick (previous, msg);
  return true;
}

WeatherStandard::WeatherStandard (Block& al)
  : WeatherBase (al),
    path (al.path ()),
    T_rain (al.number ("T_rain")),
    T_snow (al.number ("T_snow")),
    missing_years (map_submodel_const<YearMap> (al, "missing_years")),
    active_map (-1),
    timestep (0),
    begin (1900, 1, 1, 0),
    end (2100, 1, 1, 0),
    precipitation_correction (std::vector<double> (12, 1.0)),
    precipitation_scale (al.number_sequence ("PrecipScale")),
    temperature_scale (al.number_sequence ("TempScale")),
    temperature_offset (al.number_sequence ("TempOffset")),
    CO2_ (al.number ("CO2")),
    has_date (false),
    has_hour (false),
    has_temperature (false),
    has_min_temperature (false),
    has_max_temperature (false),
    has_vapor_pressure_ (false),
    has_diffuse_radiation_ (false),
    has_relative_humidity_ (false),
    has_wind_speed (false),
    has_reference_evapotranspiration_ (false),
    where (al.name ("where")),
    owned_stream (NULL),
    lex (NULL),
    end_of_header (Lexer::no_position ()),
    last_time (end),
    last_air_temperature (-42.42e42),
    last_min_air_temperature (-42.42e42),
    last_max_air_temperature (-42.42e42),
    last_global_radiation (-42.42e42),
    last_precipitation (-42.42e42),
    last_vapor_pressure (-42.42e42),
    last_diffuse_radiation (-42.42e42),
    last_relative_humidity (-42.42e42),
    last_wind_speed (-42.42e42),
    last_reference_evapotranspiration (-42.42e42),
    yesterday_T_max (-42.42e42),
    initialized (false),
    next_time (begin),
    next_year (-42.42e42),
    next_month (-42.42e42),
    next_day (-42.42e42),
    next_hour (-42.42e42),
    next_air_temperature (-42.42e42),
    next_min_air_temperature (-42.42e42),
    next_max_air_temperature (-42.42e42),
    next_global_radiation (-42.42e42),
    next_precipitation (42.42e42),
    next_vapor_pressure (-42.42e42),
    next_diffuse_radiation (-42.42e42),
    next_relative_humidity (-42.42e42),
    next_wind_speed (-42.42e42),
    next_reference_evapotranspiration (-42.42e42),
    hour (-42),
    daily_air_temperature_ (-42.42e42),
    daily_max_air_temperature_ (-42.42e42),
    daily_min_air_temperature_ (42.42e42),
    daily_global_radiation_ (-42.42e42),
    daily_precipitation_ (-42.42e42),
    snow_fraction (-42.42e42),
    rain_fraction (-42.42e42)
{ }

WeatherStandard::~WeatherStandard ()
{ }

bool
WeatherStandard::check (const Time& from, const Time& to, Treelog& err) const
{ 
  Treelog::Open nest (err, name);

  daisy_assert (lex.get ());
  bool ok = true;
  if (!lex->good ())
    {
      err.error ("file error for '" + lex->file +"'");
      return false;
    }
  if (lex->error_count > 0)
    {
      std::ostringstream tmp;
      tmp << lex->error_count << " parser errors encountered";
      err.error (tmp.str ());
      return false;
    }
  if (from < begin && find_map (from) < 0)
    {
      err.error ("Simulation starts before weather data");
      ok = false;
    }
  if (to.year () < 9000 && to > end && find_map (to) < 0)
    {
      err.error ("Simulation ends after weather data");
      ok = false;
    }
  for (unsigned int i = 0; i < missing_years.size (); i++)
    {
      std::ostringstream tmp;
      tmp << "missing_years[" << i << "]";
      Treelog::Open nest (err, tmp.str ());
      const int from_from = missing_years[i]->from.from;
      const int from_to = missing_years[i]->from.to;
      if (from_from > begin.year () && from_to < end.year ())
	{
	  std::ostringstream tmp;
	  tmp << "domain [" << from_from << "-" << from_to 
		 << "] fully within [" << begin.year () << "-" << end.year ()
		 << "]";
	  err.warning (tmp.str ());
	}
      const int to_from = missing_years[i]->to.from;
      const int to_to = missing_years[i]->to.to;
      if (to_from < begin.year () || to_to > end.year ())
	{
	  std::ostringstream tmp;
	  tmp << "range [" << to_from << "-" << to_to << "] not within [" 
		 << begin.year () << "-" << end.year () << "]";
	  err.error (tmp.str ());
	  ok = false;
	}
    }
  if (latitude () < -66 || latitude () > 66)
    {
      std::ostringstream tmp;
      tmp << "Researching arctic agriculture? (latitude = " << 
	latitude () << ")";
      err.error (tmp.str ());
    }
  return ok;
}

static struct WeatherStandardSyntax : public DeclareModel
{
  Model* make (Block& al) const
  { return new WeatherStandard (al); }

  WeatherStandardSyntax ()
    : DeclareModel (Weather::component, "default", "base", "\
Read a Daisy Weather File.")
  { }
  void load_frame (Frame& frame) const
  { 
    frame.add ("where", Value::String, Value::Const,
		"File to read weather data from.");
    frame.order ("where");

    frame.add_submodule_sequence ("missing_years", Value::Const, "\
How to get data for dates outside the range of the weather file.\n\
\n\
The value is a list of maps.  Each map consist of two intervals, and\n\
indicates that missing data from the first interval should be read\n\
from the second interval instead.  Each interval consists of two\n\
years, the first and last year of that interval.\n\
\n\
When the simulation requests weather data from a date outside the\n\
range covered by the weather file, the model will look up each member\n\
of the list, to see if the year is covered by the first interval.  If\n\
so, it will use weather data from the same day in the corresponding\n\
year in the second interval.\n\
\n\
If a given year is covered by multiple intervals in the list, the first\n\
one will be used.",
				   WeatherStandard::YearMap::load_syntax);
    frame.add_empty ("missing_years");

    // Division between Rain and Snow.
    frame.add ("T_rain", "dg C", Value::Const, 
		"Above this air temperature all precipitation is rain.");
    frame.add ("T_rain", 2.0);
    frame.add ("T_snow", "dg C", Value::Const,
		"Below this air temperature all precipitation is snow.");
    frame.add ("T_snow", -2.0);

    // Scaling.
    frame.add ("PrecipScale", Value::None (), Check::non_negative (), 
		Value::Const, 12, "\
The precipitation listed in the file will be multiplied by the number\n\
from this list before it is used in the simulation, depending on the\n\
month.  The first number corresponds to January, the second to\n\
February, etc.  For example, the number 0.5 in the first place in the\n\
list will mean the precipitation used in the simulation will be half\n\
of what is listed in the file for January, while 2.0 will mean that\n\
the precipitation used is twice the amount listed.\n\
\n\
If PrecipScale is specified both as a parameter in the Daisy setup\n\
file and PrecipCorrect as a keyword in the Daisy weather file, the two\n\
values will be multiplied together.\n\
\n\
It is suggested that the keyword is used to correct systematic\n\
mistakes in the measurement process, while the parameter is used for\n\
experimenting with different precipitation values and for reusing data\n\
from one weather station in nearby areas where only average values are\n\
known.");
    frame.add ("PrecipScale", std::vector<double> (12, 1.0));
    frame.add ("TempScale", Value::None (),
		Value::Const, 12, "\
The temperature listed in the file will be multiplied by the number\n\
from this list before it is used in the simulation, depending on the\n\
month.  The first number corresponds to January, the second to\n\
February, etc.");
    frame.add ("TempScale", std::vector<double> (12, 1.0));
    frame.add ("TempOffset", "dg C",
		Value::Const, 12, "\
Anumber from this list will be added to the temperature listed in\n\
the file before it is used in the simulation, depending on the\n\
month.  The first number corresponds to January, the second to\n\
February, etc.");
    frame.add ("TempOffset", std::vector<double> (12, 0.0));

    // C02
    frame.add ("CO2", "Pa", Value::Const, 
                "Atmostpheric CO2 lavel at station.");
    frame.add ("CO2", 35.0);

  }
} WeatherStandard_syntax;
