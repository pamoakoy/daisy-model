#summary Structure of the code for implementing tertiary transport
#labels Subject-Code

= Introduction =

This page describes the code for implementing tertiary transport in Daisy.  Tertiary transport here is the transport of water and solutes in "large" macropores, as described in the [SoilDomains soil domains] page.  The "large" macropores are macropores where the capillary forces no longer dominates, typically biopores as made by earthworms or old root channels.  Their diameter are typically in the millimeter range.

== Small and large timesteps ==

There are two different interfaces for tertiary transport, one for water transport alone in the small timesteps inside the solution of Richard's equation, and one for both water and solute transport in the large timesteps outside of the matrix water transport solution.  Solute transport always happens in the large timesteps, and water transport should only happen in one of the two, despite there being two interfaces.

Note that "small and large timesteps" doesn't actually refer to the absolute size of the timesteps, but to the fact that the model has a base timestep, which we call the large timestep, and that some processes, in this case the solutions to Richard's equation, may have to divide the large timestep into smaller units, called small timesteps.

In fact, to get solute transport right it will often be necessary to reduce the large timestep when the tertiary domain first gets activated, typically during heavy rainfall or irrigation.   But this reduction does not guarantee that the solution to Richard's equation won't require further reductions, so the small timestep interface is still needed. 

= The small timestep Interface =

The small timestep interface is called `Tertsmall` and can be found in the [http://code.google.com/p/daisy-model/source/browse/trunk/tertsmall.h tertsmall.h] file.

== State ==

The first three functions in the interface builds upon the [Anystate] abstraction.  Basically, the `Anystate` class is an opaque representation of the state of any class that supports it.  It has value semantics, which means that it can be copied, but no other operations are possible on it.   

{{{
  virtual Anystate get_state () const = 0;
  virtual void set_state (const Anystate&) = 0;
}}}

These functions allows you to extract the current state of the tertiary water and restore it again.

== Finding changes in active cells == 

{{{
  virtual void update_active (const std::vector<double>& h_matrix) = 0;
}}}

The pressure in the matrix changes between the small timesteps, which means that biopores may be activated (when the pressure is high) or deactivated (when the pressure is low).  

== Finding a solution ==

{{{
  virtual bool find_implicit_water (const Anystate& old_state, 
                                    const Geometry& geo, 
                                    const Soil& soil,  
                                    const SoilHeat& soil_heat, 
                                    const std::vector<double>& h,
                                    const double dt) = 0;
}}}

This is the main function for finding the solution.  If a solution is found, the function will return true, and the state of the `Tertwater` object will be the state of the solution.  If no solution is found, the function will return false, and the state will be reverted to `old_state`.

== Finding the sink terms ==

{{{
  virtual void matrix_sink (const Geometry& geo, const Soil& soil,  
                            const SoilHeat& soil_heat, 
                            const std::vector<double>& h,
                            std::vector<double>& S_matrix,
                            std::vector<double>& S_drain) const = 0;
}}}

Knowing the solution, we can find the matching sink terms.  `S_matrix` is the sink term for those biopores that end in the matrix, and can be both negative and positive.  It will be positive in the cells where there are active biopores, and negative in those cells where the water move back into the matrix.

== Putting it all together ==

The solution to Richard's equation basically consist of two nested loops.  The outer loop is the small timestep loop, the simulation proceeds until we reach the end of the large timestep.  The inner loop is the convergence loop, we try to better and better solutions, until we either found one that is good enough, or we have used too many iterations.  If we found a solution, we proceed to the next small timestep, otherwise we restart the convergence loop with a smaller timestep.

=== Step 1: At the beginning of each small timestep ===

{{{
  const Anystate h3_previous = tertiary.get_state ();
}}}

At the beginning of each small timestep, we need to store the state of the biopores.  This is used both in case we need to restart the convergence loop with a small timestep, and quite similar to how we need to store the state of the soil matrix.


=== Step 2: At the beginning of the convergence loop ===

{{{
  if (!tertiary.find_implicit_water (h3_previous, geo, soil, soil_heat, h_std, ddt))
    {  //We need smaller timesteps
      iterations_used = max_iterations + 1;
      break;
    }
}}}

Before trying to find a new solution for the matrix potential, we try to find a new solution for the water content in the biopores.  It might not be possible to find such a solution, in which case we want to break out of the convergence loop, and retry with small timesteps.  We set the number if iterations used to one more than the maximal number allowed, to signal that convergence was not reached.  

{{{                          
  tertiary.matrix_sink (geo, soil, soil_heat, h_std, S_matrix, S_drain);
}}}

After finding an implicit solution for the state of the biopores, we need to find the corresponding source terms for use in finding the matrix potentials.

=== Step 3: After the convergence loop ===

Once we have finished the convergence loop, what happens depends on whether we found a solution or not.

==== If we failed to find a solution ====

{{{
  tertiary.set_state (h3_previous);
}}}

If we didn't found a solution, we have to reset the state of the biopores to what they were at the beginning of the timestep.

==== If we succeeded in finding a solution ====

{{{
  tertiary.update_active (h_std);
}}}

== Implementations ==

`TertwaterNone` and `TertiaryBiopores`

= The `tertiary` component =

== The large timestep interface to water ==

== The large timestep interface to solutes ==

= The `TertiaryBiopores` class =

== The `biopore` component ==

=== The `drain` model ===

=== The `matrix` model ===






 