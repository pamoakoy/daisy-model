#summary Structure of the code for implementing tertiary transport
#labels Subject-Daisy

= Introduction =

This page describes the code for implementing tertiary transport in Daisy.  Tertiary transport here is the transport of water and solutes in "large" macropores, as described in the [SoilDomains soil domains] page.  The "large" macropores are macropores where the capillary forces no longer dominates, typically biopores as made by earthworms or old root channels.  Their diameter are typically in the millimeter range.

== Small and large timesteps ==

There are two different interfaces for tertiary transport, one for water transport alone in the small timesteps inside the solution of Richard's equation, and one for both water and solute transport in the large timesteps outside of the matrix water transport solution.  Solute transport always happens in the large timesteps, and water transport should only happen in one of the two, despite there being two interfaces.

Note that "small and large timesteps" doesn't actually refer to the absolute size of the timesteps, but to the fact that the model has a base timestep, which we call the large timestep, and that some processes, in this case the solutions to Richard's equation, may have to divide the large timestep into smaller units, called small timesteps.

In fact, to get solute transport right it will often be necessary to reduce the large timestep when the tertiary domain first gets activated, typically during heavy rainfall or irrigation.   But this reduction does not guarantee that the solution to Richard's equation won't require further reductions, so the small timestep interface is still needed. 

= The small timestep Interface =

The small timestep interface is called `Tertsmall` and can be found in the [http://code.google.com/p/daisy-model/source/browse/trunk/tertsmall.h tertsmall.h] file.

== State ==

The first three functions in the interface builds upon the [Anystate] abstraction.  Basically, the `Anystate` class is an opaque representation of the state of any class that supports it.  It has value semantics, which means that it can be copied, but no other operations are possible on it.   

{{{
  virtual Anystate get_state () const = 0;
  virtual void set_state (const Anystate&) = 0;
  virtual bool converge (const Anystate& old) = 0; // Are current, old state close?
}}}

These three functions allows you to extract the current state of the tertiary water, restore it, and see if the current state is "sufficiently close" to a previously extracted state.

== Finding changes in active cells == 

{{{
  virtual void update_active (const std::vector<double>& h_matrix) = 0;
}}}

The pressure in the matrix changes between the small timesteps, which means that biopores may be activated (when the pressure is high) or deactivated (when the pressure is low).  This function is responsible for handling that. 

== Finding a solution ==

{{{
  virtual bool find_implicit_water (const Anystate& old_state, 
                                    const Geometry& geo, 
                                    const Soil& soil,  
                                    const SoilHeat& soil_heat, 
                                    const std::vector<double>& h,
                                    const double dt) = 0;
}}}

== Finding the sink terms ==

{{{
  virtual void matrix_sink (const Geometry& geo, const Soil& soil,  
                            const SoilHeat& soil_heat, 
                            const std::vector<double>& h,
                            std::vector<double>& S_matrix,
                            std::vector<double>& S_drain) const = 0;
}}}

== Putting it all together ==


== Implementations ==

`TertwaterNone` and `TertiaryBiopores`

= The `tertiary` component =

== The large timestep interface to water ==

== The large timestep interface to solutes ==

= The `TertiaryBiopores` class =

== The `biopore` component ==

=== The `drain` model ===

=== The `matrix` model ===






 