#summary Structure of the code for implementing tertiary transport
#labels Subject-Daisy

= Introduction =

This page describes the code for implementing tertiary transport in Daisy.  Tertiary transport here is the transport of water and solutes in "large" macropores, as described in the [SoilDomains soil domains] page.  The "large" macropores are macropores where the capillary forces no longer dominates, typically biopores as made by earthworms or old root channels.  Their diameter are typically in the millimeter range.

== Small and large timesteps ==

There are two different interfaces for tertiary transport, one for water transport alone in the small timesteps inside the solution of Richard's equation, and one for both water and solute transport in the large timesteps outside of the matrix water transport solution.  Solute transport always happens in the large timesteps, and water transport should only happen in one of the two, despite there being two interfaces.

Note that "small and large timesteps" doesn't actually refer to the absolute size of the timesteps, but to the fact that the model has a base timestep, which we call the large timestep, and that some processes, in this case the solutions to Richard's equation, may have to divide the large timestep into smaller units, called small timesteps.

In fact, to get solute transport right it will often be necessary to reduce the large timestep when the tertiary domain first gets activated, typically during heavy rainfall or irrigation.   But this reduction does not guarantee that the solution to Richard's equation won't require further reductions, so the small timestep interface is still needed. 

= The small timestep Interface =

The small timestep interface is called `Tertsmall` and can be found in the [http://code.google.com/p/daisy-model/source/browse/trunk/tertsmall.h tertsmall.h] file.

== State ==

The first three functions in the interface builds upon the [Anystate] abstraction.  Basically, the `Anystate` class is an opaque representation of the state of any class that supports it.  It has value semantics, which means that it can be copied, but no other operations are possible on it.   

{{{
  virtual Anystate get_state () const = 0;
  virtual void set_state (const Anystate&) = 0;
  virtual bool converge (const Anystate& old) = 0; // Are current, old state close?
}}}

These three functions allows you to extract the current state of the tertiary water, restore it, and see if the current state is "sufficiently close" to a previously extracted state.

== Finding changes in active cells == 

{{{
  virtual void update_active (const std::vector<double>& h_matrix) = 0;
}}}

The pressure in the matrix changes between the small timesteps, which means that biopores may be activated (when the pressure is high) or deactivated (when the pressure is low).  

== Finding a solution ==

{{{
  virtual bool find_implicit_water (const Anystate& old_state, 
                                    const Geometry& geo, 
                                    const Soil& soil,  
                                    const SoilHeat& soil_heat, 
                                    const std::vector<double>& h,
                                    const double dt) = 0;
}}}

This is the main function for finding the solution.  If a solution is found, the function will return true, and the state of the `Tertwater` object will be the state of the solution.  If no solution is found, the function will return false, and the state will be reverted to `old_state`.

== Finding the sink terms ==

{{{
  virtual void matrix_sink (const Geometry& geo, const Soil& soil,  
                            const SoilHeat& soil_heat, 
                            const std::vector<double>& h,
                            std::vector<double>& S_matrix,
                            std::vector<double>& S_drain) const = 0;
}}}

Knowing the solution, we can find the matching sink terms.  `S_matrix` is the sink term for those biopores that end in the matrix, and can be both negative and positive.  It will be positive in the cells where there are active biopores, and negative in those cells where the water move back into the matrix.

== Putting it all together ==

TODO: Shouldn't update_active be called?  Maybe step 3b, if we found a solution.

TODO: This should be refphrased in terms of the two loops in the solution to Richard's equation, the time step loop, and the convergence loop.

=== Step 1: At the beginning of each  ===

{{{
  const Anystate h3_previous = tertiary.get_state ();
}}}

=== Step 2 ===

{{{
  if (!tertiary.find_implicit_water (h3_previous, geo, soil, soil_heat, h_std, ddt))
    {  //We need smaller timesteps
      iterations_used = max_iterations + 1;
      break;
    }
                          
  tertiary.matrix_sink (geo, soil, soil_heat, h_std, S_matrix, S_drain);
}}}

=== Step 3:  If we failed to find a solution ===

{{{
  tertiary.set_state (h3_previous);
}}}

== Implementations ==

`TertwaterNone` and `TertiaryBiopores`

= The `tertiary` component =

== The large timestep interface to water ==

== The large timestep interface to solutes ==

= The `TertiaryBiopores` class =

== The `biopore` component ==

=== The `drain` model ===

=== The `matrix` model ===






 