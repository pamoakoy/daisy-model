#summary Small timestep interface to tertiary water transport.
#labels Subject-Code

= Interface =

You may want to read the general description of the division of the soil into [SoilDomains three domains], as well as the desicription of the [CodeTertiary tertiary] component, for context. This page documents the small timestep interface to tertiary transport.  The interface class is called `Tertsmall` and can be found in the [http://code.google.com/p/daisy-model/source/browse/trunk/tertsmall.h tertsmall.h] file. The purpose of the `Tertsmall` interface is to allow those solution to matrix water transport that relies on dividing the problem into smaller timesteps, to have access to the tertiary domain transport mechanism between the small timesteps.

== State ==

The first three functions in the interface builds upon the [CodeAnystate Anystate] abstraction.  Basically, the `Anystate` class is an opaque representation of the state of any class that supports it.  It has value semantics, which means that it can be copied, but no other operations are possible on it.   

{{{
  virtual Anystate get_state () const = 0;
  virtual void set_state (const Anystate&) = 0;
}}}

These functions allows you to extract the current state of the tertiary water and restore it again.

== Finding changes in active cells == 

{{{
  virtual void update_active (const std::vector<double>& h_matrix) = 0;
}}}

The pressure in the matrix changes between the small timesteps, which means that biopores may be activated (when the pressure is high) or deactivated (when the pressure is low).  

== Finding a solution ==

{{{
  virtual void find_implicit_water (const Anystate& old_state, 
                                    const Geometry& geo, 
                                    const Soil& soil,  
                                    const SoilHeat& soil_heat, 
                                    const std::vector<double>& h,
                                    const double dt) = 0;
}}}

This is the main function for finding the solution.  

== Finding the sink terms ==

{{{
  virtual void matrix_sink (std::vector<double>& S_matrix,
                            std::vector<double>& S_drain) const = 0;
}}}

This functions returns the matrix sink terms that corresponds to the solution found by `find_implicit_water`.   It is only meaningful after a call to `find_implicit_water`.


= Putting it all together =

The solution to Richard's equation basically consist of two nested loops.  The outer loop is the small timestep loop, the simulation proceeds until we reach the end of the large timestep.  The inner loop is the convergence loop, we try to better and better solutions, until we either found one that is good enough, or we have used too many iterations.  If we found a solution, we proceed to the next small timestep, otherwise we restart the convergence loop with a smaller timestep.

== Step 1: At the beginning of each small timestep ==

{{{
  const Anystate h3_previous = tertiary.get_state ();
}}}

At the beginning of each small timestep, we need to store the state of the biopores.  This is used both in case we need to restart the convergence loop with a small timestep, and quite similar to how we need to store the state of the soil matrix.


== Step 2: At the beginning of the convergence loop ==

{{{
  tertiary.find_implicit_water (h3_previous, geo, soil, soil_heat, h_std, ddt);
}}}

Before trying to find a new solution for the matrix potential, we find a new solution for the water content in the biopores.  

{{{                          
  tertiary.matrix_sink (S_matrix, S_drain);
}}}

After finding an implicit solution for the state of the biopores, we need to find the corresponding source terms for use in finding the matrix potentials.

== Step 3: After the convergence loop ==

Once we have finished the convergence loop, what happens depends on whether we found a solution or not.

=== If we failed to find a solution ===

{{{
  tertiary.set_state (h3_previous);
}}}

If we didn't found a solution, we have to reset the state of the biopores to what they were at the beginning of the timestep.

=== If we succeeded in finding a solution ===

{{{
  tertiary.update_active (h_std);
}}}

If we found a solution, we should activate or deactivate biopores according to the new matrix potential.

= Implementations =

The `Tertsmall` interface is implemented by 
`TertwaterNone` (in [http://code.google.com/p/daisy-model/source/browse/trunk/tertsmall.C tertsmall.C]) and in the [CodeTertiaryBiopores TertiaryBiopores] class.  `TertwaterNone` is a dummy version of the interface, which provided no tertiary transport, and is used by tertiary transport models that rely solely on large timesteps.  A static instance is available through the `Tertsmall` interface, via the following function:

{{{
  static Tertsmall& none ();
}}}